# nezcc file

extension          = hs

# type

Bool               = Bool
Byte               = Word8
Byte[]             = ByteString
Int                = Int
Int64              = Int64
Array              = [%s]
String             = String
Tree               = AST

Some               = Just %s
None               = Nothing
None.isEmpty       = (isNothing %s)

Int64->_int        = (fromIntegral %s)
String->Byte[]     = pack %s
Byte[]->String     = unpack %s

Array.new          = []
Array.size         = (length %s)
Array.get          = (%s !! %s)
Array.slice        = (drop %s (take %s %s))

List               = IntMap
List.new           = empty
List.get           = lookup %s %s
List.add           = insert %s %s <targetList>

# syntax

comment          = -- %s
begin            =
end              =
;                =

#module           = module $|base|(parse) where
#end module       = 
struct           = data %1$s = %1$s {%2$s} deriving(Show)
record           = _%2$s :: %1$s
records          = ,
value            = %1$s {%2$s} 
valueparam       = _%1$s=%2$s
valueparams      = , 


getter           = (get %2$s %1$s)
setter           = (set %3$s %2$s %1$s)

functype         = State %1$s ️%3$s
functypeparam    = %1$s
functypeparams   = ->

const            = '''
%2$s :: %1$s
%2$s = %3$s
'''

function         = '''
%2$s :: %4$s
%2$s %3$s = 
'''
param    = %2$s
params   = 

true             = True
false            = False
$null             = NULL

val              = let %2$s = %3$s
var              = let %2$s = %3$s
assign           = %s <- %s

if               = if (%s)
else if          = else if (%s)
while            = while (%s) action accumulator
#switch           = switch(%s) {
#case             = case %s : %s
#default          = default : %s

and              = %s && %s
or               = (%s) || (%s)
not              = (not (%s))
ifexpr           = if (%1$s) then %2$s else (%3$s)

funccall         = (%s %s)
arg              = (%s)
args             = 

lambda           = \%s -> %s

#base64           = B("%s")
#bools            = B256("%s")

varname           = %s'


MEMOSIZE          = memoSize
MEMOS             = memos


imports = '''
{-# LANGUAGE TemplateHaskell #-}
module $|base|(parse) where
import Control.Monad
import qualified Control.Monad.State as MState hiding (modify)
import Control.Applicative
import Data.Word
import Data.Label
import Data.ByteString hiding (putStrLn)
import Data.ByteString.Short
import Data.IntMap (IntMap)

'''

libs = '''
data NezSubAST = Leaf String
               | Branch [(String, NezAST)] --(label,AST)
              deriving (Show)
type NezAST = (String, NezSubAST)--(Tag,SUBAST)
data AST = Tagged NezAST
         | Subtree NezSubAST
         | Notree
         deriving (Show)

data TreeLog = TreeLog {
    _op :: Int
  , _pos :: Int
  , _val :: AST
  , _tree :: AST
  , _prevLog :: TreeLog
  , _nextLog :: TreeLog
  } deriving (Show)

data State' = State' {
    _tag :: String
  , _cnt :: Int
  , _value :: String
  , _prevState :: State'
  } deriving (Show)

data NezParserContext = NezParserContext {
    _inputs :: ShortByteString
  , _length' :: Int
  , _pos1 :: Int
  , _head_pos :: Int
  , _tree1 :: AST
  , _treeLog :: TreeLog
  , _state :: State'
  , _memos :: MemoEntry
  } deriving (Show)

data MemoEntry = MemoEntry {
    _key :: Int
  , _result :: Int
  , _pos2 :: Int
  , _val2 :: AST
  } deriving (Show)

mkLabels [''TreeLog, ''NezParserContext, ''State', ''MemoEntry]

while :: (a -> Bool) -> (a -> a) -> a -> a
while praed f x
    | praed x   = while praed f (f x)
    | otherwise = x

'''



main = '''

'''

man = '''


'''